import asyncio
import logging
import os
from typing import List, Optional, Dict
from dotenv import load_dotenv
from fuzzywuzzy import fuzz #type: ignore
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    CallbackQueryHandler, ContextTypes, ConversationHandler
)
import tmdbsimple as tmdb
from transformers import MarianMTModel, MarianTokenizer

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
BOT_TOKEN = os.getenv("BOT_TOKEN")
TMDB_API_KEY = os.getenv("TMDB_API_KEY")
ITEMS_PER_PAGE = 5
CACHE_EXPIRATION = 3600  # 1 —á–∞—Å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
MAX_DESCRIPTION_LENGTH = 200  # –û–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–∞—è –¥–ª–∏–Ω–∞ –æ–ø–∏—Å–∞–Ω–∏—è

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

if not BOT_TOKEN:
    logger.error("BOT_TOKEN environment variable is not set.")
    exit(1)

if not TMDB_API_KEY:
    logger.error("TMDB_API_KEY environment variable is not set.")
    exit(1)

tmdb.API_KEY = TMDB_API_KEY

COUNTRIES = {
    "United States of America": "–°–®–ê",
    "United Kingdom": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è",
    "Russia": "–†–æ—Å—Å–∏—è",
    "France": "–§—Ä–∞–Ω—Ü–∏—è",
    "Germany": "–ì–µ—Ä–º–∞–Ω–∏—è",
    "Japan": "–Ø–ø–æ–Ω–∏—è",
    "Canada": "–ö–∞–Ω–∞–¥–∞",
    "Italy": "–ò—Ç–∞–ª–∏—è",
    "Spain": "–ò—Å–ø–∞–Ω–∏—è",
    "China": "–ö–∏—Ç–∞–π",
    "South Korea": "–Æ–∂–Ω–∞—è –ö–æ—Ä–µ—è",
    "India": "–ò–Ω–¥–∏—è",
    "Australia": "–ê–≤—Å—Ç—Ä–∞–ª–∏—è",
    "Brazil": "–ë—Ä–∞–∑–∏–ª–∏—è",
    "Mexico": "–ú–µ–∫—Å–∏–∫–∞"
}

GENRES = {
    28: "–ë–æ–µ–≤–∏–∫",
    12: "–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è",
    16: "–ú—É–ª—å—Ç—Ñ–∏–ª—å–º",
    35: "–ö–æ–º–µ–¥–∏—è",
    80: "–ö—Ä–∏–º–∏–Ω–∞–ª",
    99: "–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π",
    18: "–î—Ä–∞–º–∞",
    10751: "–°–µ–º–µ–π–Ω—ã–π",
    14: "–§—ç–Ω—Ç–µ–∑–∏",
    36: "–ò—Å—Ç–æ—Ä–∏—è",
    27: "–£–∂–∞—Å—ã",
    10402: "–ú—É–∑—ã–∫–∞",
    9648: "–ú–∏—Å—Ç–∏–∫–∞",
    10749: "–†–æ–º–∞–Ω—Ç–∏–∫–∞",
    878: "–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞",
    10770: "–¢–µ–ª–µ–≤–∏–∑–∏–æ–Ω–Ω—ã–π —Ñ–∏–ª—å–º",
    53: "–¢—Ä–∏–ª–ª–µ—Ä",
    10752: "–í–æ–µ–Ω–Ω—ã–π",
    37: "–í–µ—Å—Ç–µ—Ä–Ω"
}

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏ MarianMT –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
def init_translation_model():
    model_name = 'Helsinki-NLP/opus-mt-en-ru'
    tokenizer = MarianTokenizer.from_pretrained(model_name)
    model = MarianMTModel.from_pretrained(model_name)
    return model, tokenizer

model, tokenizer = init_translation_model()

def translate_name(name: str) -> str:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –∏–º—è –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º MarianMT."""
    try:
        translated = translate([name], model, tokenizer)
        return translated[0]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –∏–º–µ–Ω–∏ {name}: {e}")
        return name

def translate(texts, model, tokenizer):
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç —Å–ø–∏—Å–æ–∫ —Ç–µ–∫—Å—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—è —É–∫–∞–∑–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å –∏ —Ç–æ–∫–µ–Ω–∞–π–∑–µ—Ä."""
    tokenized_texts = tokenizer(texts, return_tensors='pt', padding=True, truncation=True)
    translated = model.generate(**tokenized_texts)
    return [tokenizer.decode(t, skip_special_tokens=True) for t in translated]

# –ü—Ä–æ—Å—Ç–æ–π –∫—ç—à –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
search_cache: Dict[str, Dict[str, any]] = {}

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
CHOOSE_TYPE, CHOOSE_GENRE, CHOOSE_YEAR, CHOOSE_RATING, CHOOSE_COUNTRY, SHOW_RESULTS = range(6)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏ –∫–æ–º–∞–Ω–¥–µ /start."""
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /filter –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –∏–ª–∏ /search –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é."
    )

async def filter_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–æ–≤."""
    keyboard = [
        [InlineKeyboardButton("–§–∏–ª—å–º", callback_data='type_movie'),
         InlineKeyboardButton("–°–µ—Ä–∏–∞–ª", callback_data='type_series')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:', reply_markup=reply_markup)
    return CHOOSE_TYPE

async def tmdb_search(query: str) -> Optional[List[dict]]:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ —Ñ–∏–ª—å–º–æ–≤ –∏ —Å–µ—Ä–∏–∞–ª–æ–≤ –≤ TMDb."""
    if query in search_cache and search_cache[query]['timestamp'] > asyncio.get_event_loop().time() - CACHE_EXPIRATION:
        return search_cache[query]['results']

    try:
        search = tmdb.Search()
        response = await asyncio.to_thread(search.multi, query=query, language='ru')
        results = response['results']

        filtered_results = [item for item in results if item['media_type'] in ('movie', 'tv')]
        sorted_results = sorted(
            filtered_results,
            key=lambda x: fuzz.ratio(query.lower(), x.get('title', x.get('name', '')).lower()),
            reverse=True
        )

        search_cache[query] = {
            'results': sorted_results,
            'timestamp': asyncio.get_event_loop().time()
        }

        return sorted_results
    except Exception as e:
        logger.error(f"Error in TMDb search: {e}")
        return None

async def process_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    query = update.message.text
    results = await tmdb_search(query)

    if not results:
        await update.message.reply_text("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.")
        return

    context.user_data['results'] = results
    context.user_data['query'] = query
    await send_results_page(update, context, results, 0, query)

async def send_results_page(update: Update, context: ContextTypes.DEFAULT_TYPE, results: List[dict], page: int, query: str) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–æ–∏—Å–∫–∞ –≤ –≤–∏–¥–µ –∫–Ω–æ–ø–æ–∫."""
    start = page * ITEMS_PER_PAGE
    end = start + ITEMS_PER_PAGE
    current_page_results = results[start:end]
    total_pages = (len(results) + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE  # –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü

    if not current_page_results:
        if update.callback_query:
            await update.callback_query.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
        else:
            await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
        return

    page_number = page + 1
    message_text = f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É '{query}' (–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_number} –∏–∑ {total_pages}):"

    buttons = []
    for item in current_page_results:
        title = item.get('title', item.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
        year = item.get('release_date', item.get('first_air_date', '')).split('-')[0] or "N/A"
        media_emoji = "üé¨" if item['media_type'] == 'movie' else "üì∫"
        button_text = f"{title} ({year}) {media_emoji}"
        buttons.append([InlineKeyboardButton(button_text, callback_data=f"details_{item['id']}")])

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    navigation_buttons = []
    if page > 0:
        navigation_buttons.append(InlineKeyboardButton("–ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"page_{page - 1}"))
    if end < len(results):
        navigation_buttons.append(InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è", callback_data=f"page_{page + 1}"))

    if navigation_buttons:
        buttons.append(navigation_buttons)

    reply_markup = InlineKeyboardMarkup(buttons)
    if update.callback_query:
        await update.callback_query.message.edit_text(message_text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup)

async def show_movie_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ñ–∏–ª—å–º–µ."""
    query = update.callback_query
    await query.answer()

    movie_id = query.data.split('_')[1]
    movie = tmdb.Movies(movie_id)

    try:
        response = await asyncio.to_thread(movie.info, language='ru')
        title = response.get('title', response.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
        year = response.get('release_date', '').split('-')[0]
        country_ids = response.get('production_countries', [])
        countries = ", ".join([COUNTRIES.get(c['name'], c['name']) for c in country_ids])
        genres = ", ".join([GENRES.get(genre['id'], genre['name']) for genre in response.get('genres', [])])
        rating = f"{response.get('vote_average', 0.0):.1f}"
        overview = response.get('overview', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è')

        credits_response = await asyncio.to_thread(movie.credits)
        directors = [translate_name(crew_member['name']) for crew_member in credits_response.get('crew', []) if crew_member['job'].lower() in ['director', '—Ä–µ–∂–∏—Å—Å–µ—Ä']]
        director = ", ".join(directors) if directors else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"

        cast_info = credits_response.get('cast', [])[:5]
        cast = ", ".join([translate_name(actor['name']) for actor in cast_info])

        message_text = (
            f"*üé¨ {title} ({year})*\n\n"
            f"üåç –°—Ç—Ä–∞–Ω–∞: {countries}\n"
            f"üé≠ –ñ–∞–Ω—Ä: {genres}\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {rating}\n"
            f"üé• –†–µ–∂–∏—Å—Å–µ—Ä: {director}\n"
            f"üë• –í —Ä–æ–ª—è—Ö: {cast}\n\n"
            f"üìñ{overview[:MAX_DESCRIPTION_LENGTH]}..."
        )

        keyboard = [
            [InlineKeyboardButton("–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ", callback_data=f"expand_{movie_id}")],
            [InlineKeyboardButton("–ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data=f"back_to_list_{query.message.message_id}")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Error fetching movie details: {e}")
        await query.edit_message_text("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ñ–∏–ª—å–º–µ.")

async def expand_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –ø–æ–ª–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞."""
    query = update.callback_query
    await query.answer()

    movie_id = query.data.split('_')[1]
    movie = tmdb.Movies(movie_id)

    try:
        response = await asyncio.to_thread(movie.info, language='ru')
        title = response.get('title', response.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
        year = response.get('release_date', '').split('-')[0]
        country_ids = response.get('production_countries', [])
        countries = ", ".join([COUNTRIES.get(c['name'], c['name']) for c in country_ids])
        genres = ", ".join([GENRES.get(genre['id'], genre['name']) for genre in response.get('genres', [])])
        rating = f"{response.get('vote_average', 0.0):.1f}"
        overview = response.get('overview', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è')

        credits_response = await asyncio.to_thread(movie.credits)
        directors = [translate_name(crew_member['name']) for crew_member in credits_response.get('crew', []) if crew_member['job'].lower() in ['director', '—Ä–µ–∂–∏—Å—Å–µ—Ä']]
        director = ", ".join(directors) if directors else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"

        cast_info = credits_response.get('cast', [])[:5]
        cast = ", ".join([translate_name(actor['name']) for actor in cast_info])

        message_text = (
            f"*üé¨ {title} ({year})*\n\n"
            f"üåç –°—Ç—Ä–∞–Ω–∞: {countries}\n"
            f"üé≠ –ñ–∞–Ω—Ä: {genres}\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {rating}\n"
            f"üé• –†–µ–∂–∏—Å—Å–µ—Ä: {director}\n"
            f"üë• –í —Ä–æ–ª—è—Ö: {cast}\n\n"
            f"{overview}"
        )

        keyboard = [
            [InlineKeyboardButton("–°–≤–µ—Ä–Ω—É—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ", callback_data=f"collapse_{movie_id}")],
            [InlineKeyboardButton("–ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="back_to_list")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Error expanding movie description: {e}")
        await query.edit_message_text("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ñ–∏–ª—å–º–µ.")

async def collapse_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–°–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞."""
    query = update.callback_query
    await query.answer()
    await show_movie_details(update, context)

async def handle_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–£–ø—Ä–∞–≤–ª—è–µ—Ç –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –ø—Ä–∏ –ø–æ–º–æ—â–∏ –∫–Ω–æ–ø–æ–∫."""
    query = update.callback_query
    await query.answer()

    if "back_to_list" in query.data:
        # Handle returning to the list
        await send_results_page(update, context, context.user_data['results'], 0, context.user_data['query'])
        return

    page = int(query.data.split('_')[1])
    results = context.user_data['results']
    search_query = context.user_data['query']

    await send_results_page(update, context, results, page, search_query)

async def choose_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    logger.info("Entering choose_type function")
    logger.info(f"Received callback data: {query.data}")

    try:
        if query.data.startswith("type_"):
            context.user_data['filter_type'] = query.data.split('_')[1]
            logger.info(f"Selected type: {context.user_data['filter_type']}")
        else:
            logger.error(f"Unexpected callback data: {query.data}")
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton("–ë–æ–µ–≤–∏–∫", callback_data="genre_action"),
             InlineKeyboardButton("–ö–æ–º–µ–¥–∏—è", callback_data="genre_comedy")],
            [InlineKeyboardButton("–î—Ä–∞–º–∞", callback_data="genre_drama"),
             InlineKeyboardButton("–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞", callback_data="genre_sci-fi")],
            [InlineKeyboardButton("–õ—é–±–æ–π", callback_data="skip_genre")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        logger.info("Sending genre selection message")
        await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –∂–∞–Ω—Ä:", reply_markup=reply_markup)
        logger.info("Genre selection message sent successfully")
        return CHOOSE_GENRE

    except Exception as e:
        logger.error(f"Error in choose_type: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return ConversationHandler.END

async def choose_genre(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    logger.info("Entering choose_genre function")
    logger.info(f"Received callback data: {query.data}")

    try:
        if query.data.startswith("genre_"):
            context.user_data['filter_genre'] = query.data.split('_')[1]
            logger.info(f"Selected genre: {context.user_data['filter_genre']}")
        elif query.data == "skip_genre":
            context.user_data['filter_genre'] = None
            logger.info("Genre selection skipped")
        else:
            logger.error(f"Unexpected callback data: {query.data}")
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton("2020-2023", callback_data="year_2020-2023"),
             InlineKeyboardButton("2010-2019", callback_data="year_2010-2019")],
            [InlineKeyboardButton("2000-2009", callback_data="year_2000-2009"),
             InlineKeyboardButton("–î–æ 2000", callback_data="year_pre2000")],
            [InlineKeyboardButton("–õ—é–±–æ–π", callback_data="skip_year")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        logger.info("Sending year selection message")
        await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥ –≤—ã–ø—É—Å–∫–∞:", reply_markup=reply_markup)
        logger.info("Year selection message sent successfully")
        return CHOOSE_YEAR

    except Exception as e:
        logger.error(f"Error in choose_genre: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return ConversationHandler.END

async def choose_year(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    logger.info("Entering choose_year function")
    logger.info(f"Received callback data: {query.data}")

    try:
        if query.data.startswith("year_"):
            context.user_data['filter_year'] = query.data.split('_')[1]
            logger.info(f"Selected year range: {context.user_data['filter_year']}")
        elif query.data == "skip_year":
            context.user_data['filter_year'] = None
            logger.info("Year selection skipped")
        else:
            logger.error(f"Unexpected callback data: {query.data}")
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton("–ë–æ–ª–µ–µ 8", callback_data="rating_high"),
             InlineKeyboardButton("–û—Ç 5 –¥–æ 8", callback_data="rating_medium"),
             InlineKeyboardButton("–ú–µ–Ω—å—à–µ 5", callback_data="rating_low")],
            [InlineKeyboardButton("–õ—é–±–æ–π", callback_data="skip_rating")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        logger.info("Sending rating selection message")
        await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–π—Ç–∏–Ω–≥:", reply_markup=reply_markup)
        logger.info("Rating selection message sent successfully")
        return CHOOSE_RATING

    except Exception as e:
        logger.error(f"Error in choose_year: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return ConversationHandler.END

async def choose_rating(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    logger.info("Entering choose_rating function")
    logger.info(f"Received callback data: {query.data}")

    try:
        if query.data.startswith("rating_"):
            context.user_data['filter_rating'] = query.data.split('_')[1]
            logger.info(f"Selected rating: {context.user_data['filter_rating']}")
        elif query.data == "skip_rating":
            context.user_data['filter_rating'] = None
            logger.info("Rating selection skipped")
        else:
            logger.error(f"Unexpected callback data: {query.data}")
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton(COUNTRIES[country], callback_data=f"country_{country}")]
            for country in list(COUNTRIES.keys())[:4]
        ] + [[InlineKeyboardButton("–õ—é–±–∞—è", callback_data="skip_country")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        logger.info("Sending country selection message")
        await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É:", reply_markup=reply_markup)
        logger.info("Country selection message sent successfully")
        return CHOOSE_COUNTRY

    except Exception as e:
        logger.error(f"Error in choose_rating: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return ConversationHandler.END

async def choose_country(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    logger.info("Entering choose_country function")
    logger.info(f"Received callback data: {query.data}")

    try:
        if query.data.startswith("country_"):
            context.user_data['filter_country'] = query.data.split('_')[1]
            logger.info(f"Selected country: {context.user_data['filter_country']}")
        elif query.data == "skip_country":
            context.user_data['filter_country'] = None
            logger.info("Country selection skipped")
        else:
            logger.error(f"Unexpected callback data: {query.data}")
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        # –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫
        await perform_filtered_search(update, context)

    except Exception as e:
        logger.error(f"Error in choose_country: {e}")
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return ConversationHandler.END

async def perform_filtered_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ —Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤."""
    # –ó–¥–µ—Å—å —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –ª–æ–≥–∏–∫—É –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∏–ª—å–º–∞ –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º (—Ç–∏–ø, –∂–∞–Ω—Ä, –≥–æ–¥, —Ä–µ–π—Ç–∏–Ω–≥, —Å—Ç—Ä–∞–Ω–∞).
    # –ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å –ò–î –ø–æ–∏—Å–∫–∞ –∏–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å TMDB API.

    # –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞, –∑–∞–º–µ–Ω–∏—Ç–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –Ω–∞ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –¥–µ–Ω—å:
    if update.callback_query:
        await update.callback_query.message.reply_text("–ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à—ë–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.")
    else:
        await update.message.reply_text("–ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à—ë–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.")

async def cancel_filter(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–û—Ç–º–µ–Ω—è–µ—Ç —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏."""
    logger.info("Operation canceled by user.")
    await update.message.reply_text('–ü–æ–∏—Å–∫ –æ—Ç–º–µ–Ω—ë–Ω.')
    return ConversationHandler.END

def main() -> None:
    # –°–æ–∑–¥–∞–¥–∏–º –æ–±—ä–µ–∫—Ç Application
    application = Application.builder().token(BOT_TOKEN).build()

    # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –¥–∏–∞–ª–æ–≥–æ–≤ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
    filter_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("filter", filter_command)],
        states={
            CHOOSE_TYPE: [CallbackQueryHandler(choose_type, pattern='^type_')],
            CHOOSE_GENRE: [CallbackQueryHandler(choose_genre, pattern='^genre_|^skip_genre')],
            CHOOSE_YEAR: [CallbackQueryHandler(choose_year, pattern='^year_|^skip_year')],
            CHOOSE_RATING: [CallbackQueryHandler(choose_rating, pattern='^rating_|^skip_rating')],
            CHOOSE_COUNTRY: [CallbackQueryHandler(choose_country, pattern='^country_|^skip_country')],
        },
        fallbacks=[CommandHandler("cancel", cancel_filter)],
    )

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(filter_conv_handler)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, process_search))
    application.add_handler(CallbackQueryHandler(show_movie_details, pattern=r"^details_"))
    application.add_handler(CallbackQueryHandler(expand_description, pattern=r"^expand_"))
    application.add_handler(CallbackQueryHandler(collapse_description, pattern=r"^collapse_"))
    application.add_handler(CallbackQueryHandler(handle_pagination, pattern=r"^page_|^back_to_list"))

    logger.info("Bot started")
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ polling
    application.run_polling()

if __name__ == '__main__':
    main()

