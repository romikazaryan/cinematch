import asyncio
import re
import os
from datetime import datetime
from telegram.error import BadRequest
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from configparser import ConfigParser
from motor.motor_asyncio import AsyncIOMotorClient
from dotenv import load_dotenv
from fuzzywuzzy import fuzz 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    CallbackQueryHandler, ContextTypes, ConversationHandler
)
import tmdbsimple as tmdb
from transformers import MarianMTModel, MarianTokenizer #type: ignore
import html
from asyncio import Semaphore
from cachetools import TTLCache 
# –ü–æ—Å–ª–µ –≤—Å–µ—Ö import
import logging
from pathlib import Path

# –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤
log_dir = Path('logs')
log_dir.mkdir(exist_ok=True)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler(log_dir / 'bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# –î–∞–ª–µ–µ –∏–¥—É—Ç –≤–∞—à–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã BOT_TOKEN –∏ —Ç.–¥.

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
config = ConfigParser()
config.read('config.ini')

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
BOT_TOKEN = os.getenv("BOT_TOKEN")
TMDB_API_KEY = os.getenv("TMDB_API_KEY")
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
ITEMS_PER_PAGE = int(config.get('PAGINATION', 'items_per_page', fallback=10))
CACHE_EXPIRATION = int(config.get('CACHE', 'expiration_seconds', fallback=3600))
MAX_DESCRIPTION_LENGTH = int(config.get('CONTENT', 'max_description_length', fallback=200))
API_RATE_LIMIT = int(config.get('API', 'rate_limit', fallback=20))

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
CHOOSE_TYPE, CHOOSE_GENRE, CHOOSE_YEAR, CHOOSE_RATING, CHOOSE_COUNTRY, CHOOSE_SORT, SHOW_RESULTS = range(7)

# API Rate Limiting
API_SEMAPHORE = Semaphore(API_RATE_LIMIT)

MAX_TRANSLATION_ATTEMPTS = 3

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫—ç—à–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –∏—Å—Ç–µ—á–µ–Ω–∏–µ–º —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è
search_cache = TTLCache(maxsize=100, ttl=CACHE_EXPIRATION)

# MongoDB setup
client = AsyncIOMotorClient(MONGO_URI)
db = client.movie_bot
cache_collection = db.cache

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    filename='bot.log'
)
logger = logging.getLogger(__name__)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
for var_name, var_value in [("BOT_TOKEN", BOT_TOKEN), ("TMDB_API_KEY", TMDB_API_KEY)]:
    if not var_value:
        logger.error(f"{var_name} environment variable is not set.")
        exit(1)

tmdb.API_KEY = TMDB_API_KEY

# –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å —Å—Ç—Ä–∞–Ω –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∫–æ–¥–æ–≤ ISO –≤ —Ä—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è
RU_COUNTRIES = {
    # –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä–∞–Ω—ã
    "–°–æ–≤–µ—Ç—Å–∫–∏–π –°–æ—é–∑": "SU",  # –°–°–°–†
    "–ß–µ—Ö–æ—Å–ª–æ–≤–∞–∫–∏—è": "CS",  # –î–æ —Ä–∞—Å–ø–∞–¥–∞ –≤ 1993
    "–Æ–≥–æ—Å–ª–∞–≤–∏—è": "YU",  # –î–æ —Ä–∞—Å–ø–∞–¥–∞ –≤ 1992
    "–í–æ—Å—Ç–æ—á–Ω–∞—è –ì–µ—Ä–º–∞–Ω–∏—è": "DD",  # –î–æ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –ì–µ—Ä–º–∞–Ω–∏–∏
    "–°–µ—Ä–±–∏—è –∏ –ß–µ—Ä–Ω–æ–≥–æ—Ä–∏—è": "SCG",  # –°—É—â–µ—Å—Ç–≤–æ–≤–∞–ª–∞ –≤ 2003-2006
    
    # –ö–æ–ª–æ–Ω–∏–∏ –∏ –∑–∞–≤–∏—Å–∏–º—ã–µ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
    "–ì–æ–Ω–∫–æ–Ω–≥ (–±—Ä–∏—Ç–∞–Ω—Å–∫–∞—è –∫–æ–ª–æ–Ω–∏—è)": "HK-1997",  # –î–æ –ø–µ—Ä–µ–¥–∞—á–∏ –ö–∏—Ç–∞—é
    "–ú–∞–∫–∞–æ (–ø–æ—Ä—Ç—É–≥–∞–ª—å—Å–∫–∞—è –∫–æ–ª–æ–Ω–∏—è)": "MO-1999",  # –î–æ –ø–µ—Ä–µ–¥–∞—á–∏ –ö–∏—Ç–∞—é
    # –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç—Ä–∞–Ω—ã
    "–°–®–ê": "US",
    "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è": "GB", 
    "–†–æ—Å—Å–∏—è": "RU",
    "–§—Ä–∞–Ω—Ü–∏—è": "FR",
    "–ì–µ—Ä–º–∞–Ω–∏—è": "DE", 
    "–Ø–ø–æ–Ω–∏—è": "JP",
    "–ö–∏—Ç–∞–π": "CN",
    "–Æ–∂–Ω–∞—è –ö–æ—Ä–µ—è": "KR",
    "–ö–∞–Ω–∞–¥–∞": "CA",
    "–ò—Ç–∞–ª–∏—è": "IT",
    "–ò—Å–ø–∞–Ω–∏—è": "ES",
    "–ò–Ω–¥–∏—è": "IN",
    "–ë—Ä–∞–∑–∏–ª–∏—è": "BR",
    "–ú–µ–∫—Å–∏–∫–∞": "MX",
    "–ê–≤—Å—Ç—Ä–∞–ª–∏—è": "AU",
    
    # –ï–≤—Ä–æ–ø–µ–π—Å–∫–∏–µ —Å—Ç—Ä–∞–Ω—ã
    "–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã": "NL",
    "–ë–µ–ª—å–≥–∏—è": "BE", 
    "–®–≤–µ—Ü–∏—è": "SE",
    "–ù–æ—Ä–≤–µ–≥–∏—è": "NO", 
    "–î–∞–Ω–∏—è": "DK",
    "–§–∏–Ω–ª—è–Ω–¥–∏—è": "FI",
    "–®–≤–µ–π—Ü–∞—Ä–∏—è": "CH",
    "–ê–≤—Å—Ç—Ä–∏—è": "AT",
    "–ì—Ä–µ—Ü–∏—è": "GR",
    "–ü–æ–ª—å—à–∞": "PL",
    "–ß–µ—Ö–∏—è": "CZ",
    "–í–µ–Ω–≥—Ä–∏—è": "HU",
    "–ü–æ—Ä—Ç—É–≥–∞–ª–∏—è": "PT",
    "–ò—Ä–ª–∞–Ω–¥–∏—è": "IE",
    
    # –í–æ—Å—Ç–æ—á–Ω—ã–µ —Å—Ç—Ä–∞–Ω—ã
    "–¢–∞–π–≤–∞–Ω—å": "TW", 
    "–ì–æ–Ω–∫–æ–Ω–≥": "HK",
    "–°–∏–Ω–≥–∞–ø—É—Ä": "SG",
    "–ò–Ω–¥–æ–Ω–µ–∑–∏—è": "ID",
    "–¢–∞–∏–ª–∞–Ω–¥": "TH",
    
    # –ë–ª–∏–∂–Ω–∏–π –í–æ—Å—Ç–æ–∫
    "–ò–∑—Ä–∞–∏–ª—å": "IL",
    "–¢—É—Ä—Ü–∏—è": "TR",
    "–û–ê–≠": "AE",
    
    # –î—Ä—É–≥–∏–µ —Å—Ç—Ä–∞–Ω—ã
    "–ù–æ–≤–∞—è –ó–µ–ª–∞–Ω–¥–∏—è": "NZ",
    "–ê—Ä–≥–µ–Ω—Ç–∏–Ω–∞": "AR",
    "–ö–æ–ª—É–º–±–∏—è": "CO",
    "–ß–∏–ª–∏": "CL",
    "–Æ–∂–Ω–∞—è –ê—Ñ—Ä–∏–∫–∞": "ZA",
    "–ï–≥–∏–ø–µ—Ç": "EG"
}

# –ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
ISO_TO_RU = {code: name for name, code in RU_COUNTRIES.items()}

async def get_directors(crew):
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤ —Å –ø–µ—Ä–µ–≤–æ–¥–æ–º –∏–ª–∏ —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏–µ–π.
    
    Args:
        crew (list): –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Å—ä–µ–º–æ—á–Ω–æ–π –≥—Ä—É–ø–ø—ã
    
    Returns:
        str: –°—Ç—Ä–æ–∫–∞ —Å –∏–º–µ–Ω–∞–º–∏ —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤
    """
    directors = []
    for crew_member in crew:
        if crew_member.get('job', '').lower() in ['director', '—Ä–µ–∂–∏—Å—Å–µ—Ä']:
            name = crew_member.get('name', '')
            if name:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –∏–º—è –∫–∏—Ä–∏–ª–ª–∏—Ü—É
                if re.search('[–∞-—è–ê-–Ø—ë–Å]', name):
                    directors.append(escape_html(name))  # –ï—Å–ª–∏ –∏–º—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
                else:
                    translated_name = await translation_service.translate(name)
                    if translation_service.is_valid_translation(name, translated_name):
                        directors.append(escape_html(translated_name))
                    else:
                        directors.append(escape_html(name))  # –ï—Å–ª–∏ –ø–µ—Ä–µ–≤–æ–¥ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª
    
    return ", ".join(directors) if directors else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"

def translate_country(iso_code):
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–æ–¥ —Å—Ç—Ä–∞–Ω—ã –≤ —Ä—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.
    
    Args:
        iso_code (str): –ö–æ–¥ —Å—Ç—Ä–∞–Ω—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ ISO 3166-1
    
    Returns:
        str: –†—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω—ã –∏–ª–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–¥
    """
    if not iso_code:
        return None
    
    translated = ISO_TO_RU.get(iso_code, iso_code)
    return translated

def get_production_countries(production_countries):
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ —Å –ø–µ—Ä–µ–≤–æ–¥–æ–º.
    
    Args:
        production_countries (list): –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω –∏–∑ –æ—Ç–≤–µ—Ç–∞ API
    
    Returns:
        str: –°—Ç—Ä–æ–∫–∞ —Å—Ç—Ä–∞–Ω –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞
    """
    if not production_countries:
        return "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–∞–Ω–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
    
    ru_countries = []
    for country in production_countries:
        iso_code = country.get('iso_3166_1')
        if iso_code:
            translated_country = translate_country(iso_code)
            if translated_country and translated_country not in ru_countries:
                ru_countries.append(translated_country)
    
    return ", ".join(ru_countries) if ru_countries else "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–∞–Ω–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Ñ—É–Ω–∫—Ü–∏–∏ show_movie_details
# countries = get_production_countries(response.get('production_countries', []))

# –û—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä–≤–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ GENRES
GENRES = {
    # –°–µ—Ä–∏–∞–ª—ã –∏ —Ñ–∏–ª—å–º—ã
    28: {"ru": "–ë–æ–µ–≤–∏–∫", "en": "Action"},
    12: {"ru": "–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è", "en": "Adventure"},
    16: {"ru": "–ú—É–ª—å—Ç—Ñ–∏–ª—å–º", "en": "Animation"},
    35: {"ru": "–ö–æ–º–µ–¥–∏—è", "en": "Comedy"},
    80: {"ru": "–ö—Ä–∏–º–∏–Ω–∞–ª", "en": "Crime"},
    99: {"ru": "–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π", "en": "Documentary"},
    18: {"ru": "–î—Ä–∞–º–∞", "en": "Drama"},
    10751: {"ru": "–°–µ–º–µ–π–Ω—ã–π", "en": "Family"},
    14: {"ru": "–§—ç–Ω—Ç–µ–∑–∏", "en": "Fantasy"},
    36: {"ru": "–ò—Å—Ç–æ—Ä–∏—è", "en": "History"},
    27: {"ru": "–£–∂–∞—Å—ã", "en": "Horror"},
    10402: {"ru": "–ú—É–∑—ã–∫–∞", "en": "Music"},
    9648: {"ru": "–ú–∏—Å—Ç–∏–∫–∞", "en": "Mystery"},
    10749: {"ru": "–†–æ–º–∞–Ω—Ç–∏–∫–∞", "en": "Romance"},
    878: {"ru": "–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞", "en": "Science Fiction"},
    10770: {"ru": "–¢–µ–ª–µ–≤–∏–∑–∏–æ–Ω–Ω—ã–π —Ñ–∏–ª—å–º", "en": "TV Movie"},
    53: {"ru": "–¢—Ä–∏–ª–ª–µ—Ä", "en": "Thriller"},
    10752: {"ru": "–í–æ–µ–Ω–Ω—ã–π", "en": "War"},
    37: {"ru": "–í–µ—Å—Ç–µ—Ä–Ω", "en": "Western"},

    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∂–∞–Ω—Ä—ã –¥–ª—è —Å–µ—Ä–∏–∞–ª–æ–≤
    'Talk': {"ru": "–¢–æ–∫-—à–æ—É", "en": "Talk"},
    'News': {"ru": "–ù–æ–≤–æ—Å—Ç–∏", "en": "News"},
}

# –ò –æ—Å—Ç–∞–≤–∏—Ç—å SERIES_GENRES
SERIES_GENRES = {
    10759: {"ru": "–ë–æ–µ–≤–∏–∫ –∏ –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è", "en": "Action & Adventure"},
    16: {"ru": "–ê–Ω–∏–º–∞—Ü–∏—è", "en": "Animation"},
    35: {"ru": "–ö–æ–º–µ–¥–∏—è", "en": "Comedy"},
    80: {"ru": "–ö—Ä–∏–º–∏–Ω–∞–ª", "en": "Crime"},
    99: {"ru": "–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π", "en": "Documentary"},
    18: {"ru": "–î—Ä–∞–º–∞", "en": "Drama"},
    10751: {"ru": "–°–µ–º–µ–π–Ω—ã–π", "en": "Family"},
    10762: {"ru": "–î–µ—Ç—Å–∫–∏–π", "en": "Kids"},
    9648: {"ru": "–î–µ—Ç–µ–∫—Ç–∏–≤", "en": "Mystery"},
    10763: {"ru": "–ù–æ–≤–æ—Å—Ç–∏", "en": "News"},
    10764: {"ru": "–†–µ–∞–ª–∏—Ç–∏-—à–æ—É", "en": "Reality"},
    10765: {"ru": "–ù–§ –∏ –§—ç–Ω—Ç–µ–∑–∏", "en": "Sci-Fi & Fantasy"},
    10766: {"ru": "–ú—ã–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞", "en": "Soap"},
    10767: {"ru": "–¢–æ–∫-—à–æ—É", "en": "Talk"},
    10768: {"ru": "–í–æ–µ–Ω–Ω—ã–π –∏ –ü–æ–ª–∏—Ç–∏–∫–∞", "en": "War & Politics"},
    37: {"ru": "–í–µ—Å—Ç–µ—Ä–Ω", "en": "Western"}
}



def get_genre_name(genre_id_or_name, lang='ru'):
    """
    –ü–æ–ª—É—á–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞ —Å —É—á–µ—Ç–æ–º —Ä—É—Å—Å–∫–æ–≥–æ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–æ–≤
    
    Args:
        genre_id_or_name (str/int): ID –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
        lang (str): –Ø–∑—ã–∫ ('ru' –∏–ª–∏ 'en')
    
    Returns:
        str: –ù–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
    """
    if isinstance(genre_id_or_name, (int, str)):
        genre = GENRES.get(genre_id_or_name, {})
        return genre.get(lang, str(genre_id_or_name))
    
    # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
    for genre_data in GENRES.values():
        if genre_id_or_name in genre_data.values():
            return genre_data.get(lang, genre_id_or_name)
    
    return genre_id_or_name


def get_genre_name(genre_id_or_name, lang='ru', media_type='movie'):
    """
    –ü–æ–ª—É—á–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞ —Å —É—á–µ—Ç–æ–º —Ä—É—Å—Å–∫–æ–≥–æ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–æ–≤
    
    Args:
        genre_id_or_name (str/int): ID –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
        lang (str): –Ø–∑—ã–∫ ('ru' –∏–ª–∏ 'en')
        media_type (str): –¢–∏–ø –º–µ–¥–∏–∞ ('movie' –∏–ª–∏ 'tv')
    
    Returns:
        str: –ù–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
    """
    genres_dict = SERIES_GENRES if media_type == 'tv' else GENRES
    
    if isinstance(genre_id_or_name, (int, str)):
        genre = genres_dict.get(int(genre_id_or_name) if str(genre_id_or_name).isdigit() else genre_id_or_name, {})
        return genre.get(lang, str(genre_id_or_name))
    
    # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞
    for genre_data in genres_dict.values():
        if genre_id_or_name in genre_data.values():
            return genre_data.get(lang, genre_id_or_name)
    
    return genre_id_or_name

def format_genres(genres, lang='ru', media_type='movie'):
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –∂–∞–Ω—Ä–æ–≤ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    
    Args:
        genres (list): –°–ø–∏—Å–æ–∫ –∂–∞–Ω—Ä–æ–≤
        lang (str): –Ø–∑—ã–∫ –≤—ã–≤–æ–¥–∞ ('ru' –∏–ª–∏ 'en')
        media_type (str): –¢–∏–ø –º–µ–¥–∏–∞ ('movie' –∏–ª–∏ 'tv')
    
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –∂–∞–Ω—Ä–æ–≤
    """
    formatted_genres = []
    for genre in genres:
        if isinstance(genre, dict):
            genre_id = genre.get('id')
            genre_name = genre.get('name')
            
            if genre_id is not None:
                formatted_genre = get_genre_name(genre_id, lang, media_type)
            elif genre_name is not None:
                formatted_genre = get_genre_name(genre_name, lang, media_type)
            else:
                continue
        else:
            formatted_genre = get_genre_name(genre, lang, media_type)
        
        formatted_genres.append(formatted_genre)
    
    # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, —Å–æ—Ö—Ä–∞–Ω—è—è –ø–æ—Ä—è–¥–æ–∫
    unique_genres = []
    for genre in formatted_genres:
        if genre not in unique_genres:
            unique_genres.append(genre)
    
    return ", ".join(unique_genres)

# –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–æ–¥—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

def escape_genre(genre):
    """–≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∂–∞–Ω—Ä–∞"""
    return escape_html(get_genre_name(genre))

async def translate_name(name: str) -> str:
    """
    –ü–µ—Ä–µ–≤–æ–¥–∏—Ç –∏–º—è, –µ—Å–ª–∏ –æ–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å.
    """
    translated = await translation_service.translate(name)
    return translated
    return name

class TranslationService:
    def __init__(self):
        self.model_name = 'Helsinki-NLP/opus-mt-en-ru'
        self.tokenizer = MarianTokenizer.from_pretrained(self.model_name)
        self.model = MarianMTModel.from_pretrained(self.model_name)
        self.translation_cache = TTLCache(maxsize=1000, ttl=86400)

    async def translate(self, text: str) -> str:
        logger.info(f"Attempting to translate: {text}")
        
        if not isinstance(text, str):
            logger.warning(f"Invalid input type: {type(text)}")
            return text

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if text in self.translation_cache:
            cached_result = self.translation_cache[text]
            logger.info(f"Cache hit: {text} -> {cached_result}")
            return cached_result

        MAX_TRANSLATION_ATTEMPTS = 3
        attempts = 0

        try:
            # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
            if not text or not text.strip():
                logger.warning("Empty text provided for translation")
                return text

            # –£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
            text = text.strip()
            
            while attempts < MAX_TRANSLATION_ATTEMPTS:
                logger.info(f"Translation attempt {attempts + 1}")
                
                inputs = self.tokenizer([text], return_tensors='pt', padding=True, truncation=True)
                
                logger.info("Generating translation")
                translated = self.model.generate(**inputs)
                
                logger.info("Decoding translation")
                result = self.tokenizer.decode(translated[0], skip_special_tokens=True)
                
                logger.info(f"Translation result: {result}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                if not result or not result.strip():
                    logger.warning("Empty translation result")
                    attempts += 1
                    continue

                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                if self.is_valid_translation(text, result):
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã
                    self.translation_cache[text] = result
                    logger.info(f"Successful translation: {text} -> {result}. Adding to cache.")
                    return result
                
                attempts += 1
                logger.warning(f"Invalid translation attempt for '{text}': {result}")
            
            # –ï—Å–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
            logger.error(f"Failed to translate text after {MAX_TRANSLATION_ATTEMPTS} attempts: {text}")
            return text

        except Exception as e:
            logger.exception(f"Translation error for text '{text}': {str(e)}")
            return text

    def is_valid_translation(self, original: str, translated: str) -> bool:
        logger.info(f"Validating translation: {original} -> {translated}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        if len(translated) < 2:
           logger.warning("Translation too short")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –¥–ª–∏–Ω
        if len(translated) > len(original) * 3 or len(translated) < len(original) / 3:
           logger.warning("Translation length ratio is off")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Å–ª–æ–≥–∏/–±—É–∫–≤—ã
        if re.search(r'(\w)\1{3,}', translated, re.IGNORECASE):  # –ò–∑–º–µ–Ω–µ–Ω–æ —Å {2,} –Ω–∞ {3,}
           logger.warning("Translation contains repetitive characters")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω—ã–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
        if re.search(r'(–ø—è|–ª—è|–Ω—è|–ø–ª—é)(\-–ø—è|\-–ª—è|\-–Ω—è|\-–ø–ª—é){2,}', translated, re.IGNORECASE):  # –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ—Ñ–∏—Å—ã
           logger.warning("Translation contains meaningless repetitions")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –≥–ª–∞—Å–Ω—ã—Ö –±—É–∫–≤ –≤ —Ä—É—Å—Å–∫–æ–º —Ç–µ–∫—Å—Ç–µ
        if not re.search(r'[–∞–µ—ë–∏–æ—É—ã—ç—é—è]', translated, re.IGNORECASE):
           logger.warning("Translation does not contain vowels")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Å–æ–≥–ª–∞—Å–Ω—ã—Ö –≤ —Ä—É—Å—Å–∫–æ–º —Ç–µ–∫—Å—Ç–µ
        if not re.search(r'[–±–≤–≥–¥–∂–∑–π–∫–ª–º–Ω–ø—Ä—Å—Ç—Ñ—Ö—Ü—á—à—â]', translated, re.IGNORECASE):
           logger.warning("Translation does not contain consonants")
           return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ñ–æ—Ä–º–∞—Ç—É –∏–º–µ–Ω–∏
        if any(char.isdigit() for char in translated):
           logger.warning("Translation contains digits")
           return False
        
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–ª–æ–≤–∞
        if any(len(word) > 20 for word in translated.split()):
           logger.warning("Translation contains too long words")
           return False
    
        logger.info("Translation passed validation")
        return True
    
    def clear_cache(self):
        logger.info("Clearing translation cache")
        self.translation_cache.clear()

# –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–µ—Ä–≤–∏—Å–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
translation_service = TranslationService()

async def rate_limited_api_call(func: callable, *args, **kwargs) -> Any:
    async with API_SEMAPHORE:
        try:
            return await asyncio.to_thread(func, *args, **kwargs)
        except Exception as e:
            logger.error(f"API call error: {e}")
            raise

async def get_media_details(media_id: str, media_type: str) -> Optional[Dict]:
    cache_key = f"{media_type}_{media_id}"
    
    cached_data = await cache_collection.find_one({"_id": cache_key})
    if cached_data and datetime.utcnow() - cached_data['timestamp'] < timedelta(seconds=CACHE_EXPIRATION):
        return cached_data['data']

    try:
        media = tmdb.Movies(media_id) if media_type == 'movie' else tmdb.TV(media_id)
        response = await rate_limited_api_call(media.info, language='ru')
        
        await cache_collection.update_one(
            {"_id": cache_key},
            {
                "$set": {
                    "data": response,
                    "timestamp": datetime.utcnow()
                }
            },
            upsert=True
        )
        
        return response
    except Exception as e:
        logger.error(f"Error fetching {media_type} details: {e}")
        return None
    
async def translate_name(name: str) -> str:
    return await translation_service.translate(name)


def escape_html(text: str) -> str:
    return html.escape(str(text))

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [InlineKeyboardButton("–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é", callback_data='search_by_title')],
        [InlineKeyboardButton("–ü–æ–∏—Å–∫ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É", callback_data='search_by_filter')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–∫–∞—Ç—å —Ñ–∏–ª—å–º—ã –∏ —Å–µ—Ä–∏–∞–ª—ã –¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏:\n"
        "1. –ü—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞.\n"
        "2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /filter –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º.",
        reply_markup=reply_markup
    )

async def back_to_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data.clear()
    
    keyboard = [
        [InlineKeyboardButton("–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é", callback_data='search_by_title')],
        [InlineKeyboardButton("–ü–æ–∏—Å–∫ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É", callback_data='search_by_filter')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        "–í—ã –º–æ–∂–µ—Ç–µ –∏—Å–∫–∞—Ç—å —Ñ–∏–ª—å–º—ã –∏ —Å–µ—Ä–∏–∞–ª—ã –¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏:\n"
        "1. –ü—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞.\n"
        "2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /filter –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º.",
        reply_markup=reply_markup
    )

async def handle_main_menu_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é."""
    query = update.callback_query
    await query.answer()
    
    logger.info(f"Main menu selection: {query.data}")
    
    if query.data == 'search_by_title':
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞:")
        return ConversationHandler.END
    
    elif query.data == 'search_by_filter':
        logger.info("Attempting to start filter search")
        keyboard = [
            [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")],
            [
                InlineKeyboardButton("üé¨ –§–∏–ª—å–º", callback_data='type_movie'),
                InlineKeyboardButton("üì∫ –°–µ—Ä–∏–∞–ª", callback_data='type_series')
            ],
            [InlineKeyboardButton("üé¨üì∫ –í—Å–µ", callback_data='type_all')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:', reply_markup=reply_markup)
        return CHOOSE_TYPE
    
    elif query.data == 'back_to_type':
        keyboard = [
            [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")],
            [
                InlineKeyboardButton("üé¨ –§–∏–ª—å–º", callback_data='type_movie'),
                InlineKeyboardButton("üì∫ –°–µ—Ä–∏–∞–ª", callback_data='type_series')
            ],
            [InlineKeyboardButton("üé¨üì∫ –í—Å–µ", callback_data='type_all')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:', reply_markup=reply_markup)
        return CHOOSE_TYPE

    logger.warning(f"Unhandled callback data: {query.data}")
    return ConversationHandler.END

async def tmdb_search(query: str) -> Optional[List[dict]]:
    if query in search_cache:
        return search_cache[query]
    
    try:
        search = tmdb.Search()
        response = await rate_limited_api_call(search.multi, query=query, language='ru')
        
        if not response or 'results' not in response:
            logger.warning(f"No results found for query: {query}")
            return []
        
        results = response['results']
        filtered_results = [item for item in results if item['media_type'] in ('movie', 'tv')]
        
        # –°–Ω–∞—á–∞–ª–∞ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ (—Å–æ–≤–ø–∞–¥–µ–Ω–∏—é —Å –∑–∞–ø—Ä–æ—Å–æ–º)
        sorted_by_relevance = sorted(
            filtered_results,
            key=lambda x: fuzz.ratio(query.lower(), x.get('title', x.get('name', '')).lower()),
            reverse=True
        )
        
        # –ë–µ—Ä–µ–º —Ç–æ–ø-10 —Å–∞–º—ã—Ö —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        top_relevant = sorted_by_relevance[:10]
        
        # –ó–∞—Ç–µ–º —Å–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö –ø–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏
        final_results = sorted(
            top_relevant,
            key=lambda x: float(x.get('popularity', 0)),
            reverse=True
        )
        
        # –û—Å—Ç–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü
        remaining_results = sorted_by_relevance[10:]
        final_results.extend(remaining_results)
        
        search_cache[query] = final_results
        return final_results
    
    except Exception as e:
        logger.error(f"Error in TMDb search: {e}")
        return None

async def process_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.message.text.strip()
    if not query:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞.")
        return
    
    results = await tmdb_search(query)
    if not results:
        await update.message.reply_text("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.")
        return
    
    context.user_data['results'] = results
    context.user_data['query'] = query
    await send_results_page(update, context, results, 0, query)


async def send_results_page(update: Update, context: ContextTypes.DEFAULT_TYPE, results: List[dict], page: int, query: str) -> None:
    start = page * ITEMS_PER_PAGE
    end = start + ITEMS_PER_PAGE
    current_page_results = results[start:end]
    total_pages = (len(results) + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    
    if not current_page_results:
        if update.callback_query:
            await update.callback_query.answer()
            await update.callback_query.edit_message_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
        else:
            await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
        return
    
    page_number = page + 1
    
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    navigation_buttons = []
    if total_pages > 1:
        if page > 0:
            navigation_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"page_{page - 1}"))
        navigation_buttons.append(InlineKeyboardButton(f"{page_number}/{total_pages}", callback_data="current_page"))
        if end < len(results):
            navigation_buttons.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"page_{page + 1}"))
    
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–≤ –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞)
    result_buttons = []
    for i in range(0, len(current_page_results), 2):
        row = []
        if i < len(current_page_results):
            item1 = current_page_results[i]
            title1 = item1.get('title', item1.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
            title1 = (title1[:30] + '...') if len(title1) > 33 else title1
            year1 = item1.get('release_date', item1.get('first_air_date', '')).split('-')[0] or "N/A"
            media_emoji1 = "üé¨" if item1['media_type'] == 'movie' else "üì∫"
            button1 = InlineKeyboardButton(f" {title1} ({year1}) {media_emoji1} ", callback_data=f"details_{item1['id']}_{item1['media_type']}")
            row.append(button1)
        
        if i + 1 < len(current_page_results):
            item2 = current_page_results[i + 1]
            title2 = item2.get('title', item2.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
            title2 = (title2[:30] + '...') if len(title2) > 33 else title2
            year2 = item2.get('release_date', item2.get('first_air_date', '')).split('-')[0] or "N/A"
            media_emoji2 = "üé¨" if item2['media_type'] == 'movie' else "üì∫"
            button2 = InlineKeyboardButton(f" {title2} ({year2}) {media_emoji2} ", callback_data=f"details_{item2['id']}_{item2['media_type']}")
            row.append(button2)
        
        result_buttons.append(row)
    
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É "–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
    main_menu_button = [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")]
    
    # –°–æ–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É: —Å–Ω–∞—á–∞–ª–∞ –∫–Ω–æ–ø–∫–∞ "–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", –∑–∞—Ç–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –∑–∞—Ç–µ–º –∫–Ω–æ–ø–∫–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    keyboard = [main_menu_button] + result_buttons + [navigation_buttons]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è '{query}' (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page_number}/{total_pages}):",
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è '{query}' (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page_number}/{total_pages}):",
            reply_markup=reply_markup
        )

async def show_movie_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    callback_data = query.data.split('_')
    media_id = callback_data[1]
    media_type = callback_data[2] if len(callback_data) > 2 else 'movie'

    try:
        if media_type == 'movie':
            media = tmdb.Movies(media_id)
            response = await asyncio.to_thread(media.info, language='ru')
            title = escape_html(response.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
            year = response.get('release_date', '').split('-')[0] if response.get('release_date') else "N/A"
        else:
            media = tmdb.TV(media_id)
            response = await asyncio.to_thread(media.info, language='ru')
            title = escape_html(response.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'))
            year = response.get('first_air_date', '').split('-')[0] if response.get('first_air_date') else "N/A"

        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç—Ä–∞–Ω –Ω–∞ —Ä—É—Å—Å–∫–æ–º
        production_countries = response.get('production_countries', [])
        ru_countries = []
        for country in production_countries:
            iso_code = country.get('iso_3166_1')
            if iso_code in ISO_TO_RU:
                ru_countries.append(ISO_TO_RU[iso_code])
            
        countries = ", ".join(ru_countries) if ru_countries else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∂–∞–Ω—Ä—ã
        genres = format_genres(response.get('genres', []), lang='ru', media_type=media_type)
        rating = f"{response.get('vote_average', 0.0):.1f}"
        overview = escape_html(response.get('overview', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è'))

        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–∑–¥–∞—Ç–µ–ª—è—Ö
        credits_response = await asyncio.to_thread(media.credits)
        directors = []
        
        if media_type == 'tv':
            # –î–ª—è —Å–µ—Ä–∏–∞–ª–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª–µ–π –∏ —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤
            creators = response.get('created_by', [])
            for creator in creators:
                if creator.get('name'):
                    name = creator.get('name')
                    if re.search('[–∞-—è–ê-–Ø—ë–Å]', name):
                        directors.append(escape_html(name))
                    else:
                        translated_name = await translation_service.translate(name)
                        if translation_service.is_valid_translation(name, translated_name):
                            directors.append(escape_html(translated_name))
                        else:
                            directors.append(escape_html(name))
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤ –¥–ª—è –æ–±–æ–∏—Ö —Ç–∏–ø–æ–≤
        for crew_member in credits_response.get('crew', []):
            if crew_member.get('job', '').lower() in ['director', '—Ä–µ–∂–∏—Å—Å–µ—Ä']:
                name = crew_member.get('name')
                if name:
                    if re.search('[–∞-—è–ê-–Ø—ë–Å]', name):
                        directors.append(escape_html(name))
                    else:
                        translated_name = await translation_service.translate(name)
                        if translation_service.is_valid_translation(name, translated_name):
                            directors.append(escape_html(translated_name))
                        else:
                            directors.append(escape_html(name))

        director = ", ".join(set(directors)) if directors else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–µ—Ä–æ–≤
        cast_info = credits_response.get('cast', [])[:5]
        cast = ", ".join([escape_html(await translate_name(actor['name'])) 
                 for actor in cast_info])

        message_text = (
            f"<b>üé¨ {title} ({year})</b>\n\n"
            f"üåç –°—Ç—Ä–∞–Ω–∞: {countries}\n"
            f"üé≠ –ñ–∞–Ω—Ä: {genres}\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {rating}\n"
            f"üé• –†–µ–∂–∏—Å—Å–µ—Ä: {director}\n"
            f"üë• –í —Ä–æ–ª—è—Ö: {cast}\n\n"
            f"üìñ {overview[:MAX_DESCRIPTION_LENGTH]}..."
        )

        keyboard = [
    [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")],
    [InlineKeyboardButton("–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ", callback_data=f"expand_{media_id}_{media_type}")],
    [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data=f"back_to_list_{query.message.message_id}")]
]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode='HTML')

    except Exception as e:
        logger.error(f"Error fetching {media_type} details: {e}")
        await query.edit_message_text("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ñ–∏–ª—å–º–µ.")

async def expand_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    try:
        media_id = query.data.split('_')[1]
        media_type = query.data.split('_')[2] if len(query.data.split('_')) > 2 else 'movie'

        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∏–ª—å–º–µ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–µ
        media = tmdb.TV(media_id) if media_type == 'tv' else tmdb.Movies(media_id)
        response = await asyncio.to_thread(media.info, language='ru')

        if not response:
            raise ValueError("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–µ–¥–∏–∞")

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –≥–æ–¥
        title = escape_html(response.get('name', response.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')))
        date_field = 'first_air_date' if media_type == 'tv' else 'release_date'
        year = response.get(date_field, '').split('-')[0] if response.get(date_field) else "N/A"

        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–π/—Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤
        creators = []
        try:
            credits_response = await asyncio.to_thread(media.credits)
            
            if media_type == 'tv':
                # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤ –∏ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–π
                director_jobs = ['director', 'series director', 'directing', 'television director', 'creator', 'created by']
                
                if credits_response and 'crew' in credits_response:
                    for crew_member in credits_response['crew']:
                        job = crew_member.get('job', '').lower()
                        if job in director_jobs:
                            name = crew_member.get('name', '')
                            if name and isinstance(name, str):
                                translated_name = await translation_service.translate(name)
                                if translated_name and isinstance(translated_name, str) and translated_name != name:
                                    creators.append(escape_html(translated_name))
                                else:
                                    creators.append(escape_html(name))
                
                # –ï—Å–ª–∏ —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤/—Å–æ–∑–¥–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞—à–ª–∏ –≤ crew, –∏—â–µ–º –≤ created_by
                if not creators:
                    for creator in response.get('created_by', []):
                        if creator and isinstance(creator, dict) and creator.get('name'):
                            name = creator.get('name')
                            if isinstance(name, str):
                                translated_name = await translation_service.translate(name)
                                if translated_name and isinstance(translated_name, str) and translated_name != name:
                                    creators.append(escape_html(translated_name))
                                else:
                                    creators.append(escape_html(name))
            else:
                # –î–ª—è —Ñ–∏–ª—å–º–æ–≤ –∏—â–µ–º —Ç–æ–ª—å–∫–æ —Ä–µ–∂–∏—Å—Å–µ—Ä–æ–≤
                if credits_response and 'crew' in credits_response:
                    for crew_member in credits_response['crew']:
                        if crew_member.get('job', '').lower() == 'director':
                            name = crew_member.get('name', '')
                            if name and isinstance(name, str):
                                translated_name = await translation_service.translate(name)
                                if translated_name and isinstance(translated_name, str) and translated_name != name:
                                    creators.append(escape_html(translated_name))
                                else:
                                    creators.append(escape_html(name))
        except Exception as e:
            logger.error(f"Error getting creators/directors: {e}")
            creators = []

        director = ", ".join(creators) if creators else "–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"

        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç—Ä–∞–Ω—ã –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞
        production_countries = response.get('production_countries', [])
        ru_countries = []
        for country in production_countries:
            iso_code = country.get('iso_3166_1')
            if iso_code in ISO_TO_RU:
                ru_countries.append(ISO_TO_RU[iso_code])
            
        countries = ", ".join(ru_countries) if ru_countries else "–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∂–∞–Ω—Ä—ã
        genres = format_genres(response.get('genres', []), lang='ru', media_type=media_type)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥
        rating = f"{response.get('vote_average', 0.0):.1f}"
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
        overview = escape_html(response.get('overview', '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'))

        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–µ—Ä–æ–≤
        cast_names = []
        if credits_response and 'cast' in credits_response:
            for actor in credits_response['cast'][:5]:
                if actor.get('name') and isinstance(actor['name'], str):
                    translated_name = await translation_service.translate(actor['name'])
                    if translated_name and isinstance(translated_name, str) and translated_name != actor['name']:
                        cast_names.append(escape_html(translated_name))
                    else:
                        cast_names.append(escape_html(actor['name']))
        
        cast = ", ".join(cast_names) if cast_names else "–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        message_text = (
            f"<b>{'üì∫' if media_type == 'tv' else 'üé¨'} {title} ({year})</b>\n\n"
            f"üåç –°—Ç—Ä–∞–Ω–∞: {countries}\n"
            f"üé≠ –ñ–∞–Ω—Ä: {genres}\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {rating}\n"
            f"üé• –†–µ–∂–∏—Å—Å–µ—Ä: {director}\n"
            f"üë• –í —Ä–æ–ª—è—Ö: {cast}\n\n"
            f"{overview}"
        )

        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏
        keyboard = [
    [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")],
    [InlineKeyboardButton("–°–≤–µ—Ä–Ω—É—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ", callback_data=f"collapse_{media_id}_{media_type}")],
    [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="back_to_list")]
]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        await query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode='HTML')

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –æ–ø–∏—Å–∞–Ω–∏—è {'—Å–µ—Ä–∏–∞–ª–∞' if media_type == 'tv' else '—Ñ–∏–ª—å–º–∞'}: {e}")
        await query.edit_message_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")
            ]])
        )

async def collapse_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–°–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞."""
    query = update.callback_query
    await query.answer()

    # –ü–æ–ª—É—á–∞–µ–º ID –∏ —Ç–∏–ø –º–µ–¥–∏–∞ –∏–∑ callback_data
    callback_data = query.data.split('_')
    media_id = callback_data[1]
    media_type = callback_data[2] if len(callback_data) > 2 else 'movie'  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ñ–∏–ª—å–º

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –∫—Ä–∞—Ç–∫–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é
    await show_movie_details(update, context)

async def handle_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    results = context.user_data.get('results')
    search_query = context.user_data.get('query')

    if not results or not search_query:
        await query.edit_message_text("–°–µ—Å—Å–∏—è –ø–æ–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫.")
        return

    total_pages = (len(results) + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

    if query.data == "page_first":
        page = 0
    elif query.data == "page_last":
        page = total_pages - 1
    elif query.data.startswith("page_"):
        page = int(query.data.split('_')[1])
    elif query.data == "back_to_search":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞:")
        context.user_data.clear()
        return
    elif "back_to_list" in query.data:
        page = 0
    else:
        page = 0

    await send_results_page(update, context, results, page, search_query)

async def filter_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏."""
    context.user_data.clear()  # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    keyboard = [
        [
            InlineKeyboardButton("–§–∏–ª—å–º", callback_data='type_movie'),
            InlineKeyboardButton("–°–µ—Ä–∏–∞–ª", callback_data='type_series')
        ],
        [InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:', 
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:', 
            reply_markup=reply_markup
        )
    
    return CHOOSE_TYPE

async def choose_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–í—ã–±–æ—Ä —Ç–∏–ø–∞ (—Ñ–∏–ª—å–º/—Å–µ—Ä–∏–∞–ª)."""
    query = update.callback_query
    await query.answer()
    
    if query.data == "back_to_main_menu":
        return await back_to_main_menu(update, context)
    
    if query.data.startswith("type_"):
        context.user_data['filter_type'] = query.data.split('_')[1]
        
        genre_keyboard = [
            [
                InlineKeyboardButton("–ë–æ–µ–≤–∏–∫", callback_data="genre_28"),
                InlineKeyboardButton("–ö–æ–º–µ–¥–∏—è", callbac